\section{Алгоритм Бойкова-Колмогорова}

\subsection{Задача знаходження Min-Cut/Max-Flow}

Ведемо позначення:
$T$ - множина вузлів графу (рис. \ref{fig:graph_example}), 
$\tau$ - множина направлених дуг,
$s$ - джерело (початок),
$e$ - стік (кінець),
$N_t = \{t^{'}: tt^{'} \in \tau \}$,
$P_t = \{t^{'}: t^{'}t \in \tau \}$,
$f$ - потік,
$c$ - пропускна здатність,

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{images/graph_example}
    \caption{Приклад графу}
    \label{fig:graph_example}
\end{figure}

Задача максимального потоку

\begin{equation}
    \sum_{t \in N_s} f_{st} \rightarrow \max_{f: \tau \rightarrow R }
\end{equation}

З обмеженнями: 
\begin{equation} 
    \begin{gathered}
        \begin{cases}
            f_{tt^{'}} \leq  c_{tt^{'}}, &  \forall tt^{'}  \in \tau , \\

            \sum_{p \in P_t} f_{pt} - \sum_{t^{'} \in N_t} f_{tt^{'}} = 0, & 
            \forall t \in T \setminus \{s,e\}, \\

            \sum f_{tt^{'}} \geq 0, & \forall tt^{'}  \in \tau
        \end{cases}
\end{gathered}
\end{equation}

Що значить:
\begin{enumerate}
    \item Потік має не перевищувати пропускну здатність для всіх ребер;
    \item Сума потоків, що входять у вузол не повинна змінитись на виході;
    \item Потік завжди додатній.
\end{enumerate}

Оригінальний алгоритм:

\begin{algorithm}[H]
    \caption{Алгоритм Min-Cut/Max-Flow}
    \begin{algorithmic}
    \State \textbf{Вхід:} Граф, з об'єктами $t \in T$, ребрами $tt^{'}$
    \State \textbf{Вихід:} $F_{maxflow}$ - значення максимального потоку;
    \State \textbf{Ініціалізація}: $F_{maxflow} = 0, f_{tt^{'}}^{0} = 0 \quad  \forall tt^{'}  \in \tau$.
    \State \textbf{Поки існує шлях з $s$ в $e$ повторюємо кроки 1,2}:    
    \State \textbf{Крок 1}: Знаходимо шлях від $s$ до $e$.
    (алгоритм Едмонса-Карпа або Форда Фалкерсона).
    \State Відвідуємо $t^{'}$ із $t$ якщо:
            \State \qquad 1. $f_{tt^{'}} \neq   c_{tt^{'}}$
            \State \qquad 2. $ \nexists p_{t^{'}}^{i} \Rightarrow  p_{t^{'}}^{i} = t $ (запам'ятали вершину)
            \State \qquad 3. $ t^{'} \neq s $
    \State \textbf{Крок 2}: Проходимо по заданому шляху: 
            \State \qquad 1. Знаходимо $ \vartriangle f^{i} = \min_{tt^{'} \in \{шлях із s в e \}} $
            \State \qquad 2. Змінюємо потік: $ f_{tt^{'}}^{i+1} = f_{tt^{'}}^{i} + \vartriangle f^{i} $
            \State \qquad 3. Оновлюємо $F_{maxflow}$: $ F_{maxflow}^{i+1}  = F_{maxflow}^{i} + \vartriangle f^{i} $ 
    \end{algorithmic}

Знайшовши максимальний потік можемо знайти мінімальний зріз:
Для $\forall t \in T$ знайти $\theta_{t} \in \{0,1\}$
    \begin{algorithmic}
    \State \textbf{Крок 3}: Запускаємо пошук в ширину або глибину вже з оновленим графом.   
    \State \qquad Якщо $c_{tt^{'}} \geqslant f_{tt^{'}}$ та $c_{tt^{'}} \geqslant 0$
    $\Rightarrow \theta_{t^{'}} = 1 $, інакше $\theta_{t^{'}} = 0 $
    \end{algorithmic}
\end{algorithm}

У 2004 році Юрій Бойков та Володимир Колмогоров запропонували модификацію вищеописаного
методу.
Запропонована ідея методу полягає в огментації шляхів. Будується два дерева $S$ та $T$
коренями яких є $s$ та $t$ відповідно. Вершини загально діляться на ті що в $S$, $T$, та 
\textit{вільні}. Кожне дерево має \textit{активні} та \textit{внутрішні} вершини.
Алгоритм складається зі стадій \textit{росту}, \textit{огментації}, \textit{всиновлення}.\\
Коротко розглянемо кожну з них:

\begin{enumerate}
    \item \textbf{Стадія Росту}. \\
        Відбувається одночасний ріст дерев з вершин $s$ та $e$, знаходяться активні
        вершини і додають їх як вершини, що відвідали. Після такого сканування вершини 
        стають внутрішніми. Цей процес продовжується поки не зостанеться не активної вершини.
    \item \textbf{Стадія Огментації}. \\
        На цій стадії шлях, що був знайдений на попередньому етапі огментується(розділення)
        по ребру залишкової пропускної здатності (\textit{bottleneck}). Якщо ребра дерева стають 
        насиченими (пропускна здатність = потоку) найвіддаленіші вершини від коренів дерев стають
        \textit{сиротами}. Тобто, якщо наприклад вершини $t$ та $t^{'}$ знаходяться в дереві $S$
        і ребро $(t,t^{'})$ є насиченим, тоді $t^{'}$ називається \textit{$S$ - сиротою}.
        Аналогічно, якщо $t$ та $t^{'}$ знаходяться в дереві $T$, то  $t$ - \textit{$T$ - сирота}.
        Якщо ребро знаходиться в \textit{bottleneck}( $t$ в $S$, $t^{'}$ в $T$, ребро $(t,t^{'})$ 
        насичене) відповідно немає ніяких сиріт. Всі сироти потрапляють у список сирот. 
    \item \textbf{Стадія Всиновлення}. \\
        На даному етапі ми проходимось по кожній сироті в списку сирот для кожного дерева.
        Нехай $t^{'}$ \textit{$S$ - сирота}. Знаходимо всі $t$  в $S$, які формують ребро 
        ($t$, $t^{'}$). Для кожного такого $t$ перевіряємо чи шлях з $t$ в $s$ містить сироти
        включаючи $t$. Якщо сирот не знайшли, то $t$ - батько  $t^{'}$. \\
        Якщо не вдається знайти батька, ми позначаємо вершину $t^{'}$ як \textit{вільну}, а всіх
        дітей $t^{'}$ сиротами. Після цього ми оброблюємо залишкові ребра $(t,t^{'})$ і для кожного $t$ в $S$ позначаємо
        $t$ - активною. 
\end{enumerate}


\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth]{images/graph_cut}
    \caption{Приклад графу-решітки з мінімальним розрізом
    \label{fig:graph_lattice}
    }
\end{figure}

Найбільша перевага даного алгоритму це те що, він працює швидше та краще на графах-решітках 
(рис.\ref{fig:graph_lattice}).
Оскільки саме таку структуру ми використовуємо в алгоритмі Б-К для отримання маски рухомих 
об'єктів це дає змогу оброблювати кадри відео досить швидко.
